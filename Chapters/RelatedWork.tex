%BitTorrent
\section{BitTorrent}
BitTorrent \citep{bittorrent:bep03} is a peer-to-peer protocol for file sharing designed by Bram Cohen in 2001.
The protocol is responsible for around 30 percent of the data uploaded to the internet.
The traditional way to use the BitTorrent protocol is to use a BitTorrent desktop client. That is a computer program that implements the BitTorrent protocol.
The .torrent files comes with a meta-data file that includes a tracker-list. The BitTorrent tracker is a server that contains information about what peers are interested in a given torrent. The tracker can connect a peer to other peers with the same torrent so the first peer can download and upload torrent data from and to those peers.

\subsection{File sharing}
Torrents is a very popular and easy method to share large files, because every user providing bandwidth i.e. the seeding of the torrents.
The payload of the server that initially shared the file does not have to be big, because the user will share the file with other users instead of overloading the server.
%tracker hash forbinde folk 

\subsection{BEP - BitTorrent Enhancement Proposals}
BitTorrent enhancement proposals is a place where users of BitTorrent can come with proposals to improve the protocol.
One of these proposals focuses on \acs{HTTP} seeding \citep{bittorrent:bep17}.
This is relevant in our work, because we focus on how we can make streaming work in the browser. The proposal is about changing the meta-data file to include a \acs{HTTP} seeds key. This key would refer to a list of web addresses where the torrent data can be downloaded from.
If support for \acs{HTTP} seeds would be added to the BitTorrent protocol it would mean that there is more uptime of seeds because the ftp and \acs{HTTP} server would always be up.

In another proposal \citep{bittorrent:bep09} it is proposed to make it possible for clients to join a swarm and complete a download without having to download a .torrent file first, from an info hash contained in magnet links. The gains from using magnet links over torrents are that information about the torrent can be downloaded directly from other peers. Regular torrent files needs to be placed upon a web-server where it takes up space. The server must be up and running for the users to get information about the torrent, and that is not needed with using magnet links.
Now users can just share a link instead of sharing a file on a server.

Private torrents is another feature in BitTorrent \citep{bittorrent:bep27}. They idea is that users can define a torrent to be private by setting 'private=1' in the meta-info (.torrent) file. Private trackers can be used to control what users are allowed to download a torrent. The tracker is a server with a list of the peers that contain pieces of the torrent and a list of users allowed to get the specific torrent.
The tracker will refuse to provide a seed-list to those not allowed to get that torrent.

%Storing arbitrary data in the \acs{DHT}
In a proposal \citep{bittorrent:bep44} it is suggested that the \acs{DHT} of BitTorrent is extended with the possibility of storing arbitrary data instead of just storing key-value pairs with hashes and associated \acs{IP}-addresses.
With this change the \acs{DHT} could be used to store information about the torrent e.g. song length, author, file size, etc.

\section{HTML5}
HTML5 is the latest markup language for writing web applications is was released in 2014. Some of the new tags introduced is video and audio tags which makes it possible to play video and audio in the player build into HTML5.

HTML5 also implements local storage. This makes it possible to store content locally in the browsers rather than use cookies, to store the data.
The storage limit it larger than when using cookies (at least 5MB) and the data is stored locally so it does not need to be sent to a server.

\subsection{HTML5 Audio Tag}
\label{sec:HTML5_audio_tag}
Most modern browsers support the \acs{HTML}5 standard Audio tag,
also called \acs{HTML}5 Audio and WebAudio,
which presents a simple \acs{GUI} and audio playback to the user.
Browsers also support a similar Video tag, 
which could also be used for audio playback purposes.
The audio and video tags support both files and streams, 
allowing playback while a file is still being downloaded.
\newline
Supported audio codings differ greatly between browsers:
Firefox and Opera do not support the proprietary formats Mp3, Mp4 or ADTS
without additional software on the machine.
Safari does not support the free open source formats WebM or Ogg,
and Internet Explorer and Microsoft Edge does not support anything other than Mp3 and Mp4.
Google chrome notably supports all the above formats.
\newline

\begin{figure}[H]
    \centering
    \includegraphics[scale=0.5]{gfx/audioTag.jpg}
    \caption{A picture of Audio Tag \acs{GUI} in Firefox}
    \label{fig:audiotag}
\end{figure}

The audio tag itself offers a very simplistic yet very inflexible \acs{GUI} to the user, 
it includes the usual progress bar, volume, play+pause buttons in its interface, 
these elements cannot be easily changed, but can be disabled and hidden entirely, 
which lets the audio playback be controlled by JavaScript code instead.

\section{Popular content distributors}
The are many music-streamers already released and we will let us get inspired by some of the most popular and give a walk-trough of them below.

\subsection{Spotify}
Spotify is the most popular online music streamer. The program was released in 2006 and was developed in Sweden Stockholm by Daniel Ek and Martin Lorentzon. Now their main office is placed in Luxemborg and they have divisions in Stockholm and GÃ¶teborg. Their business model is that customers can listen to music in exchange for listening to commercials between tracks, or they can pay a monthly fee to be premium members.
The music is placed on servers controlled by Spotify in contrast to the peer-to-peer music streamer we will develop.
\begin{figure}[H]
  \centering
    \includegraphics[width=0.9\textwidth]{gfx/Spotify_desktop.jpg}
  \caption{A picture of the \acs{GUI} in the Spotify desktop application}
  \label{fig:spotify}
\end{figure}
\noindent
As seen in Figure~\ref{fig:spotify} the music player is placed in the bottom of the application, there is a menu at the left of the screen where your personal play-lists can be accessed, and where it is possible to browse for new music and listen to a radio channel.
Spotify now have over 75 mission active users, both from Europe, America and Asia. Spotify both have clients for desktops and mobiles.

\subsection{Napster}
Napster was when it was released in 1999 a peer-to-peer file sharing service that focused on audio files. Napster was co-founded by Shawn Fanning, John Fanning, and Sean Parker The Napster site was only operational until 2001 because it was sued by Metallica for sharing music illegally. It was then brought down by court order. Metallica learned that their song "I disappear" was available on Napster before it was released witch also led to it be played on radios. Napster peaked at 25 million users in January 2001 On March 13, 2000 Metallica filed a lawsuit against Napster. Many  In addition to the Napster web-page, a desktop client was developed both to windows and later to MAC OS.
Napster had to pay 36\$ in royalties to various music companies and had to declare themselves bankrupt. Roxio bought the assets of Napster to relaunch it as a online music store, where users had to pay money for each track. In may 2006 Roxio launched a free version of Napster where users where able to stream full length tracks, where the service was powered by adds. They had the limit that each song could only be streamed 3 times each by every user, but they had 8million songs to choose from.
The free Napster service was discontinued in March 2010, because Napster was sold to Best Buy in January 2010.
Rhapsody (another streaming and download service) bought Napster in 2011 and transformed it into a subscription based streaming client for desktop or phones.

\subsection{Popcorn-Time}
Popcorn-time is a multi-platform BitTorrent client for streaming videos. The popcorn-time interface is much similar to that of Netflix. It presents the user with thumbnail images of the movies and when the user selects a picture the movie is then downloaded with the BitTorrent protocol, and played in the build-in player.
 When a download starts the movie is also seeded to other peers in the network. The seeding continues until the content i deleted with usually happens when the application closes.
 In 2014 developers made popcorn-time available on android, and support for Chromecast and Apple TV.

\subsection{Netflix}
Netflix is the largest streaming company. As seen in \citep{netflix} they were looking into the possibilities of using WebTorrent in their company. At the time of the article Netflix had a job application for a peer-to-peer senior developer. Netflix is not using any peer-to-peer protocol today so the project was not a huge success.

\subsection{Gnutella}
\label{sec:gnutella}
Gnutella \citep{Androutsellis-Theotokis:2004:SPC:1041680.1041681},\citep{gnutella:specifikation} is a purely decentralized peer-to-peer network from 2000 it was developed by Justin Frankel and Tom Pepper of Nullsoft. Gnutella was removed from the servers the day after because of legal concerns, but the protocol was reversed engineered by the community and open source clones began to appear.
The users in Gnutella is called servants, and the protocol consists of a set of descriptors for communication between servants:
\begin{itemize}
\item Ping: This is used to actively discover hosts on the network. A servant receiving a ping descriptor is expected to respond with one or more Pong descriptors.
\item Pong: This is a response to a Ping. It includes the IP address and port number of the responding host and information of how much data it is making available to the network (number and size of the files being shared).
\item Query: The primary tool to search for information in the network. A servant receiving a Query will respond with a QueryHit if a match is found in its local data-set. It contains a search string and the minimum speed requirements of the responding host.
\item QueryHit: It is a response to a query. It contains the IP address and port, and bandwidth speed of the responding host. It also contains the number of matching files found and their indexed result set.
\item Push: This mechanism allows a firewalled servant to push file-based data to the network.
\end{itemize}
When a new servant joins the network by connecting to servants found in databases such as \url{http://gnutellahosts.com} its neighborhood list is empty. The neighborhood is the list of nodes a servant knows. A servant sends a ping message to all the servants it is connected to, those nodes then sends back a pong message, and they also forwards the ping message to their neighbors.
Since the network is unstructured the only way of locating a file is non-deterministic. The original Gnutella network used a flooding mechanism where each node forwards the request to its neighbors recursively. The response to a query will be routed back the way it came so the receiver of a query stores information about the servant it received the query from until the query has timed out. Each message header contains a time-to-live(TTL) field. At each hop the value of the TTL is decremented, and when it reaches zero the message is dropped. In Gnutella each node have a routing table to keep track of the messages it receives. The servants stores message identifiers and node addresses. Since the response messages contains the same id as the original messages the host knows from which servant it got the message from.
Once a node receives a QueryHit message it initiates a direct connection between the node that replied back and the servant asking for the file.

\section{Browser versus desktop}
The above mentioned systems are either implemented via. a web-browser +
centralized backend server, or by means of a desktop application.

To ease usability we've decided that our application must run within the
context of the web-browser. I.e. that users will not have to install a desktop
application first. This has several implications, amongst others;
\begin{itemize}
\item Limited access to hardware
\item Limited connection layer technologies
    \begin{itemize}
        \item \acs{HTTP}
        \item WebSockets (see \citep{RFC6455})
        \item WebRTC (see \citep{WebRTC})
    \end{itemize}
\item Limited access to persistent storage
    \begin{itemize}
        \item LocalStorage (see \citep{WebStorage})
        \item IndexedDB (see \citep{IndexedDB})
        \item WebSQL (no longer maintained, see \citep{WebSQL})
    \end{itemize}
\end{itemize}
We are aware of the fact, that these limitations will make it harder for us to
prove our hypothesis, but we believe that the proof will be stronger and more
convincing given the limitations of the web-browser context.

\subsection{Browserify}
Browserify is a tool, which bundles up multiple JavaScript files into a single
file, it does so by intelligently parsing files, and handling include
statements, this enables us to write code with utilizes \verb|node.js|'s require
include within our code, and additionally enables us to utilize libraries from
the node package manager (\verb|npm|), a walk-through of the most significant 
libraries we've utilized can be found in section~\ref{sec:libraries}.

Additionally Browserify handles multiple target architectures; I.e. the browser,
and the node.js desktop environment. We originally envisioned creating both a 
web-interface and a more technical desktop client, but due to time constraints,
we've limited ourselves to the desktop client.

\subsection{WebSocket}
\input{Chapters/WebSockets}

\subsection{WebRTC}
WebRTC is a JavaScript \acs{API} drafted by W3C that establishes support for browser-to-browser connections,
instead of traditional client-server connections like WebSockets, AJAX and Server Sent Events.
These client-server networks suffer from high latency, and do not allow browsers to act as a server,
as browsers cannot listen for WebSocket connections.

It was originally intended to support real-time-communication (RTC) 
and allow browsers to easily establish audio and video teleconferencing and telecommunications
using its three primary \acs{API}s: MediaStream, RTCPeerConnection and RTCDataConnection.
The RTCDataConnection part of the \acs{API} is particularly interesting
as it allows arbitrary application data to be sent between browsers,
allowing a myriad of peer-to-peer techniques to be implemented as WebRTC code for browsers.

Before WebRTC, establishing direct peer-to-peer connections in the browser required
additional plugins in the browser such as Flash or Java, which would then download the necessary networking code
from a server and execute it locally,
these plugins did not come with most browsers,
which means many users did not have them available.
\newline

\label{webrtc-connection-server}
When using WebRTC, we must first notify the remote peer of our intention
to open a peer-to-peer connection, so it can start listening for incoming packet,
we also have to establish the necessary routing paths to each other peer on both sides,
and relay this information,
and finally establish the intended parameters: protocols, encoding used, and so on.

\begin{figure}[H]
	\centering
	\includegraphics[scale=0.4]{gfx/webrtc-connect}
	\caption{Overview of WebRTC - Courtesy of HTML5rocks.com}
	\label{fig:webrtc-connect}
\end{figure}

For the purposes of notifying the remote peer, a signaling service is necessary,
this means having a centralized server that the browser contacts and asks to have a connection created.
The signaling service does not need to be involved after the connection has been established,
it can free up its resources to focus on signaling for new peers, 
while the already established connections can continue regardless of whether the signalling service has quit.
It is also necessary to create routing information:
real-life users are often behind one or many layers of firewalls, 
and need to arrange the necessary open ports.
Each browser also needs to discover its own IP address on the public web, 
and this information may be obscured by the OS or local intranet.
WebRTC makes use of a STUN server on the public internet, 
which will return messages sent to it and provide the connecting IP address to the sender.
WebRTC also makes use of a TURN server backup mechanism in case direct peer-to-peer connectivity fails,
TURN servers are used to relay actual data and not signaling data, they have public addresses, 
so they can be contacted even from behind a firewall.
